# Coprocessor SIG 工作流

## 任务领取

Coprocessor SIG 任务以 issue 的形式组织，任务都关联到 [Copr SIG](https://github.com/tikv/tikv/issues?q=is%3Aissue+is%3Aopen+label%3A%22C%3A+Copr+SIG%22) Label 中，可以结合自己的兴趣和对源码的理解程度在 TiKV 的 Coprocessor SIG 的列表中选择适合自己难度的 issue，这些难度划分为：

- L = Low 低难度，只需要了解 Coprocessor 一小部分知识并使用较少代码量完成
- M = Medium 中难度，需要了解 Coprocessor 多种知识或需要显著代码量完成
- H = High 高难度，需要完全了解 Coprocessor 或需要非常多代码量完成
- S = Super High 超高难度，需要结合 TiKV 其他部分甚至 TiDB、系统编程等综合性知识完成

## 编码

当选定 issue 之后需要根据 issue 的类型以及难度进行后续的工作，对于简单的任务可以直接进行编码；对于复杂或者大量重构的 issue 需要先写文档，文档需要覆盖一下内容：

1. 方案概述：对于这个方案的概括性介绍
2. 可行性分析：在目前的架构下当前方案是否可行
3. 兼容性分析：本次改动是否会打破向后兼容性
4. 性能分析：本次改动是否存在性能提升或性能回退
5. 设计细节：需要通过 issue 的形式与 Maintainer、Committer 进行讨论，最终达成一致后开始编码

部分任务可能涉及外部其他组件的修改，比如 TiDB 或 PD。对于这类任务，为了保证整个任务的完整性，需要在对应的项目中提交 PR，并且推动测试和合并。

## 测试

为了保证代码的执行和代码的维护性，以及约束后续 PR 不破坏当前定义的行为（如果是有意识的修改当前行为，需要有测试能反馈出行为的修改），对于任何有逻辑改动的 PR，都需要添加对应的单元测试和集成测试。

### 单元测试

- 我们为什么需要单元测试？

  - 验证程序的行为。
  
    针对一个具体的函数或模块，在编码前会定义它的行为，定义不同的输入时对应的输出。所以需要通过添加单元测试来覆盖程序的每一个执行路径都会得到预期的结果。不但是为了验证它的正确性，也为以后的开发提供保证。后期开发与维护中可以轻松的增加功能或更改程序结构，而不用担心这个过程中会破坏重要的东西，同时为代码的重构提供了保障，使后续的重构能验证是否破坏定义的行为和假设。

  - 它是一种设计行为。
    
    编写单元测试将使我们从调用者观察、思考，迫使我们把程序设计成易于调用和可测试的，即迫使我们解除软件中的耦合。

  - 它是一种编写文档的行为。

    单元测试是一种无价的文档，它是展示函数或类如何使用的最佳文档。这份文档是可编译、可运行的，并且它保持最新，永远与代码同步。

  - 它具有回归性。
    
    自动化的单元测试避免了代码出现回归，编写完成之后，可以随时随地的快速运行测试。

- 单元测试四问
  
  - 它的行为和我期望的一致吗？

    这是单元测试最根本的目的，我们就是用单元测试的代码来证明它所做的就是我们所期望的。

  - 它的行为一直和我期望的一致吗？

    编写单元测试，如果只测试代码的一条正确路径，让它正确走一遍，并不算是真正的完成。软件开发是一个项复杂的工程，在测试某段代码的行为是否和你的期望一致时，你需要确认：在任何情况下，这段代码是否都和你的期望一致；譬如参数很可疑、硬盘没有剩余空间、缓冲区溢出、网络掉线的时候。

  - 我可以依赖单元测试吗？

    不能依赖的代码是没有多大用处的。既然单元测试是用来保证代码的正确性，那么单元测试也一定要值得依赖。

  - 单元测试说明我的意图了吗？

    单元测试能够帮我们充分了解代码的用法，从效果上而言，单元测试就像是能执行的文档，说明了在你用各种条件调用代码时，你所能期望这段代码完成的功能。

### 集成测试

单元测试用于测试单个模块或函数的行为是否符合预期，但是 TiKV 是复杂的大型项目，由大量类似的小模块构成，当各个小模块都能通过单元测试保证行为的正确性时，我们还是需要集成测试来保证所有模块组合之后整个 TiKV 组件依然复合预期，以及与 TiDB、PD 组成集群时能满足预期的行为。

TiKV 中的集成测试分类两类：

1. TiKV 单组件集成测试
   
   组合 TiKV 的已有模块验证正确性，对应的代码在 TiKV 项目的 `tests/integration` 目录

2. TiKV、TiDB、PD 多组件集群集成测试
   
   提交 PR 时，由 CI 触发的 `integration-*` 前缀的测试即为这类集成测试，对于 Coprocessor SIG 来做主要需要关注 [`integration-copr-test`](https://github.com/tikv/copr-test)。`copr-test` 主要用于保证下推算子和函数在 Coprocessor 和 TiBD 中的执行结果一致。

## 示例

本小节以从 TiDB port 一个函数到 Coprocessor 为例来简要描述工作流：

1. 从 TiDB 中选择一个还未下推的函数，TiDB 中一个函数是否下推，可以通过 TiDB 的 [`canFuncBePushed`](https://github.com/pingcap/tidb/blob/master/expression/expr_to_pb.go) 函数判断。
2. 选择一个未下推的函数后，就可以参考 TiDB 中的逻辑，在 Coprocessor 的 Expression 模块添加对应的函数实现。
3. 当将对应的函数 port 到 Coprocessor 之后，就可以 port 对应的测试，如果 TiDB 的测试没有完全覆盖所有的执行路径，需要补充必要的测试。
4. 补充对应的测试之后就可以在 TiDB 中提交 PR，将 port 的函数添加到下推列表中，CI 会触发测试，如果已有的测试未通过，根据测试结果修复实现。
5. 当已有测试完全通过之后，需要在 [`copr-test`](https://github.com/tikv/copr-test) 添加专门的集成测试来覆盖新 port 的函数。以下以 `CAST` 函数为例：
   1. 创建一个表 `create table a (a decimal (20,9));`
   2. 向表中插入一些数据 `insert into a values ('1', '2', '1231231231231231');`
   3. 测试语句 `select * from t where a = 1;`，这里的 case 是利用 TiDB 将 Selection 算子下推到 Coprocessor，由于 `a` 的类型与比较的目标类型不同，会插入 `cast` 函数，由此触发执行 `cast` 逻辑，如果不确定 port 的函数是否下推，可以查看对应的执行计划或在程序中埋点。 
6. 当所有的测试通过之后，PR 就可以进入后续的 Review 以及合并流程。
